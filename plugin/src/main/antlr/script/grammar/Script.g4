grammar Script;

@header {package script.grammar;}

file: (variable | constant | assign | function | for_statement | while_statement | class_statement | extends_statement | class_name | enum_statement | if_statement | elif | else_statement | return_statement | PASS | signal | expression)+ EOF;
variable: (EXPORT (BRACE_LEFT export_argument? (COMMA export_argument)* BRACE_RIGHT)?)? ONREADY? VAR IDENTIFIER (COLON type)? (ASSIGN expression)? (SETGET IDENTIFIER? (COMMA IDENTIFIER)?)?;
export_argument: IDENTIFIER | NUMBER | STRING | type;
constant: CONST IDENTIFIER (COLON type)? ASSIGN expression;
assign: expression (ASSIGN | ASSIGN_SPECIAL) expression;
function: STATIC? FUNC IDENTIFIER BRACE_LEFT argument? (COMMA argument)* BRACE_RIGHT (ARROW type)? COLON;
argument: IDENTIFIER (COLON type)?;
invoke: IDENTIFIER list;
for_statement: FOR expression COLON;
while_statement: WHILE expression COLON;
class_statement: CLASS IDENTIFIER COLON;
extends_statement: EXTENDS type;
class_name: CLASS_NAME IDENTIFIER;
enum_statement: ENUM IDENTIFIER? PARENTHES_LEFT enum_entry (COMMA enum_entry)* PARENTHES_RIGHT;
enum_entry: IDENTIFIER (ASSIGN NUMBER)?;
if_statement: IF expression COLON;
elif: ELIF expression COLON;
else_statement: ELSE COLON;
return_statement: RETURN expression;
signal: SIGNAL IDENTIFIER;
subscribe: IDENTIFIER BRACKET_LEFT expression BRACKET_RIGHT;
list: BRACE_LEFT expression? (COMMA expression)* BRACE_RIGHT;
array: BRACKET_LEFT expression? (COMMA expression)* BRACKET_RIGHT;
dictionary: PARENTHES_LEFT dictionary_entry? (COMMA dictionary_entry)* PARENTHES_RIGHT;
dictionary_entry: (STRING | NUMBER) COLON expression;
dictionary_lua_style: PARENTHES_LEFT dictionary_lua_style_entry? (COMMA dictionary_lua_style_entry)* PARENTHES_RIGHT;
dictionary_lua_style_entry: IDENTIFIER ASSIGN expression;
expression: value ((OPERATION_SIGN | AND | OR | IN | IS | AS | MINUS | DOT) value)*;
value: (MINUS | NOT)? (invoke | subscribe | list | array | dictionary | dictionary_lua_style | IDENTIFIER | NODE | NUMBER | STRING | SELF | TRUE | FALSE | MULTILINE_STRING | LINE_COMMENT);
type: IDENTIFIER | BOOL | INT | FLOAT | VOID;

EXPORT: 'export';
ONREADY: 'onready';
VAR: 'var';
SETGET: 'setget';
CONST: 'const';
STATIC: 'static';
FUNC: 'func';
FOR: 'for';
WHILE: 'while';
CLASS: 'class';
EXTENDS: 'extends';
CLASS_NAME: 'class_name';
ENUM: 'enum';
IF: 'if';
ELIF: 'elif';
ELSE: 'else';
RETURN: 'return';
PASS: 'pass';
SIGNAL: 'signal';
ASSIGN_SPECIAL: '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=';
ASSIGN: '=';
ARROW: '->';
OPERATION_SIGN: '~' | '*' | '/' | '%' | '+' | '<<' | '>>' | '&' | '^' | '|' | '<' | '>' | '==' | '!=' | '>=' | '<=' | '!' | '&&' | '||';
NOT: 'not';
AND: 'and';
OR: 'or';
IN: 'in';
IS: 'is';
AS: 'as';
SELF: 'self';
TRUE: 'true';
FALSE: 'false';
BOOL: 'bool';
INT: 'int';
FLOAT: 'float';
VOID: 'void';
COMMA: ',';
DOT: '.';
COLON: ':';
BRACE_LEFT: '(';
BRACE_RIGHT: ')';
BRACKET_LEFT: '[';
BRACKET_RIGHT: ']';
PARENTHES_LEFT: '{';
PARENTHES_RIGHT: '}';
IDENTIFIER: IDENTIFIER_START (IDENTIFIER_START | DIGIT)*;
NODE: '$' (LOWER_CASE | UPPER_CASE | '/')*;
MINUS: '-';
NUMBER: MINUS? DIGIT+ '.'? (DIGIT+)?;
STRING: '"' (~["\n])* '"';
MULTILINE_STRING: '"""' .*? '"""';
LINE_COMMENT: '#' ~[\r\n\f]*;
fragment IDENTIFIER_START: LOWER_CASE | UPPER_CASE | '_';
fragment LOWER_CASE: 'a'..'z';
fragment UPPER_CASE: 'A'..'Z';
fragment DIGIT: '0'..'9';

WHITESPACE: (' ' | [\t\n])+ -> channel(HIDDEN);
ERRCHAR: . -> channel(HIDDEN);
